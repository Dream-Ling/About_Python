<html>
<head>
  <title>Python2.x与3​​.x版本区别</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600753 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="4301"/>
<h1>Python2.x与3​​.x版本区别</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>作者：</b></td><td><i>凌小康</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><h1>Python2.x与3​​.x版本区别</h1><p>Python的3​​.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。</p><p>为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下相容。</p><p>许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。</p><p>为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。</p><p>新的Python程式建议使用Python 3.0版本的语法。</p><p>除非执行环境无法安装Python 3.0或者程式本身使用了不支援Python 3.0的第三方库。目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。</p><p>大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。</p><p>Python 3.0的变化主要在以下几个方面:</p><hr/><h2>print 函数</h2><p>print语句没有了，取而代之的是print()函数。 Python 2.6与Python 2.7部分地支持这种形式的print语法。在Python 2.6与Python 2.7里面，以下三种形式是等价的：</p><pre><span>print</span><span> </span><span>&quot;fish&quot;</span><span>
</span><span>print</span><span> </span><span>(</span><span>&quot;fish&quot;</span><span>)</span><span> </span><span>#注意print后面有个空格</span><span>
</span><span>print</span><span>(</span><span>&quot;fish&quot;</span><span>)</span><span> </span><span>#print()不能带有任何其它参数</span></pre><p>然而，Python 2.6实际已经支持新的print()语法：</p><pre><span>from</span><span> __future__ </span><span>import</span><span> print_function
</span><span>print</span><span>(</span><span>&quot;fish&quot;</span><span>,</span><span> </span><span>&quot;panda&quot;</span><span>,</span><span> sep</span><span>=</span><span>', '</span><span>)</span></pre><hr/><h2>Unicode</h2><p>Python 2 有 ASCII str() 类型，unicode() 是单独的，不是 byte 类型。</p><p>现在， 在 Python 3，我们最终有了 Unicode (utf-8) 字符串，以及一个字节类：byte 和 bytearrays。</p><p></p><p>由于 Python3.X 源码文件默认使用utf-8编码，这就使得以下代码是合法的：</p><pre><span>&gt;&gt;&gt;</span><span> </span><span>中国</span><span> </span><span>=</span><span> </span><span>'china'</span><span> 
</span><span>&gt;&gt;&gt;</span><span>print</span><span>(中国)</span><span> 
china</span></pre><p>Python 2.x</p><pre><span>&gt;&gt;&gt;</span><span> str </span><span>=</span><span> </span><span>&quot;我爱北京天安门&quot;</span><span>
</span><span>&gt;&gt;&gt;</span><span> str
</span><span>'\xe6\x88\x91\xe7\x88\xb1\xe5\x8c\x97\xe4\xba\xac\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8'</span><span>
</span><span>&gt;&gt;&gt;</span><span> str </span><span>=</span><span> u</span><span>&quot;我爱北京天安门&quot;</span><span>
</span><span>&gt;&gt;&gt;</span><span> str
u</span><span>'\u6211\u7231\u5317\u4eac\u5929\u5b89\u95e8'</span></pre><p>Python 3.x</p><pre><span>&gt;&gt;&gt;</span><span> str </span><span>=</span><span> </span><span>&quot;我爱北京天安门&quot;</span><span>
</span><span>&gt;&gt;&gt;</span><span> str
</span><span>'我爱北京天安门'</span></pre><hr/><h2>除法运算</h2><p>Python中的除法较其它语言显得非常高端，有套很复杂的规则。Python中的除法有两个运算符，/和//</p><p>首先来说/除法:</p><p>在python 2.x中/除法就跟我们熟悉的大多数语言，比如Java啊C啊差不多，整数相除的结果是一个整数，把小数部分完全忽略掉，浮点数除法会保留小数点的部分得到一个浮点数的结果。</p><p>在python 3.x中/除法不再这么做了，对于整数之间的相除，结果也会是浮点数。</p><p>Python 2.x:</p><pre><span>&gt;&gt;&gt;</span><span> </span><span>1</span><span> </span><span>/</span><span> </span><span>2</span><span>
</span><span>0</span><span>
</span><span>&gt;&gt;&gt;</span><span> </span><span>1.0</span><span> </span><span>/</span><span> </span><span>2.0</span><span>
</span><span>0.5</span></pre><p>Python 3.x:</p><pre><span>&gt;&gt;&gt;</span><span> </span><span>1</span><span>/</span><span>2</span><span>
</span><span>0.5</span></pre><p>而对于//除法，这种除法叫做floor除法，会对除法的结果自动进行一个floor操作，在python 2.x和python 3.x中是一致的。</p><p>python 2.x:</p><pre><span>&gt;&gt;&gt;</span><span> </span><span>-</span><span>1</span><span> </span><span>// 2</span><span>
</span><span>-</span><span>1</span></pre><p>python 3.x:</p><pre><span>&gt;&gt;&gt;</span><span> </span><span>-</span><span>1</span><span> </span><span>// 2</span><span>
</span><span>-</span><span>1</span></pre><p>注意的是并不是舍弃小数部分，而是执行 floor 操作，如果要截取整数部分，那么需要使用 math 模块的 trunc 函数</p><p>python 3.x:</p><pre><span>&gt;&gt;&gt;</span><span> </span><span>import</span><span> math
</span><span>&gt;&gt;&gt;</span><span> math</span><span>.</span><span>trunc</span><span>(</span><span>1</span><span> </span><span>/</span><span> </span><span>2</span><span>)</span><span>
</span><span>0</span><span>
</span><span>&gt;&gt;&gt;</span><span> math</span><span>.</span><span>trunc</span><span>(-</span><span>1</span><span> </span><span>/</span><span> </span><span>2</span><span>)</span><span>
</span><span>0</span></pre><hr/><h2>异常</h2><p>在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 as 作为关键词。</p><p>捕获异常的语法由 <b>except exc, var</b> 改为 <b>except exc as var</b>。</p><p>使用语法except (exc1, exc2) as var可以同时捕获多种类别的异常。 Python 2.6已经支持这两种语法。</p><ul><li>1. 在2.x时代，所有类型的对象都是可以被直接抛出的，在3.x时代，只有继承自BaseException的对象才可以被抛出。</li><li>2. 2.x raise语句使用逗号将抛出对象类型和参数分开，3.x取消了这种奇葩的写法，直接调用构造函数抛出对象即可。</li></ul><p></p><p>在2.x时代，异常在代码中除了表示程序错误，还经常做一些普通控制结构应该做的事情，在3.x中可以看出，设计者让异常变的更加专一，只有在错误发生的情况才能去用异常捕获语句来处理。</p><hr/><h2>xrange</h2><p>在 Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。</p><p>这个表现十分像生成器（比如。&quot;惰性求值&quot;）。但是这个 xrange-iterable 是无穷的，意味着你可以无限遍历。</p><p>由于它的惰性求值，如果你不得仅仅不遍历它一次，xrange() 函数 比 range() 更快（比如 for 循环）。尽管如此，对比迭代一次，不建议你重复迭代多次，因为生成器每次都从头开始。</p><p>在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。</p><pre><span>import</span><span> timeit

n </span><span>=</span><span> </span><span>10000</span><span>
</span><span>def</span><span> test_range</span><span>(</span><span>n</span><span>):</span><span>
    </span><span>return</span><span> </span><span>for</span><span> i </span><span>in</span><span> range</span><span>(</span><span>n</span><span>):</span><span>
        </span><span>pass</span><span>

</span><span>def</span><span> test_xrange</span><span>(</span><span>n</span><span>):</span><span>
    </span><span>for</span><span> i </span><span>in</span><span> xrange</span><span>(</span><span>n</span><span>):</span><span>
        </span><span>pass</span><span>   </span></pre><p>Python 2</p><pre><span>print</span><span> </span><span>'Python'</span><span>,</span><span> python_version</span><span>()</span><span>

</span><span>print</span><span> </span><span>'\ntiming range()'</span><span> 
</span><span>%</span><span>timeit test_range</span><span>(</span><span>n</span><span>)</span><span>

</span><span>print</span><span> </span><span>'\n\ntiming xrange()'</span><span> 
</span><span>%</span><span>timeit test_xrange</span><span>(</span><span>n</span><span>)</span><span>

</span><span>Python</span><span> </span><span>2.7</span><span>.</span><span>6</span><span>

timing range</span><span>()</span><span>
</span><span>1000</span><span> loops</span><span>,</span><span> best of </span><span>3</span><span>:</span><span> </span><span>433</span><span> </span><span>µ</span><span>s per loop


timing xrange</span><span>()</span><span>
</span><span>1000</span><span> loops</span><span>,</span><span> best of </span><span>3</span><span>:</span><span> </span><span>350</span><span> </span><span>µ</span><span>s per loop</span></pre><p>Python 3</p><pre><span>print</span><span>(</span><span>'Python'</span><span>,</span><span> python_version</span><span>())</span><span>

</span><span>print</span><span>(</span><span>'\ntiming range()'</span><span>)</span><span>
</span><span>%</span><span>timeit test_range</span><span>(</span><span>n</span><span>)</span><span>

</span><span>Python</span><span> </span><span>3.4</span><span>.</span><span>1</span><span>

timing range</span><span>()</span><span>
</span><span>1000</span><span> loops</span><span>,</span><span> best of </span><span>3</span><span>:</span><span> </span><span>520</span><span> </span><span>µ</span><span>s per loop</span></pre><pre><span>print</span><span>(</span><span>xrange</span><span>(</span><span>10</span><span>))</span><span>
</span><span>---------------------------------------------------------------------------</span><span>
</span><span>NameError</span><span>                                 </span><span>Traceback</span><span> </span><span>(</span><span>most recent call </span><span>last</span><span>)</span><span>
</span><span>&lt;</span><span>ipython</span><span>-</span><span>input</span><span>-</span><span>5</span><span>-</span><span>5d8f9b79ea70</span><span>&gt;</span><span> </span><span>in</span><span> </span><span>&lt;module&gt;</span><span>()</span><span>
</span><span>----&gt;</span><span> </span><span>1</span><span> </span><span>print</span><span>(</span><span>xrange</span><span>(</span><span>10</span><span>))</span><span>

</span><span>NameError</span><span>:</span><span> name </span><span>'xrange'</span><span> </span><span>is</span><span> </span><span>not</span><span> </span><span>defined</span></pre><hr/><h2>八进制字面量表示</h2><p>八进制数必须写成0o777，原来的形式0777不能用了；二进制必须写成0b111。</p><p>新增了一个bin()函数用于将一个整数转换成二进制字串。 Python 2.6已经支持这两种语法。</p><p>在Python 3.x中，表示八进制字面量的方式只有一种，就是0o1000。</p><p>python 2.x</p><pre><span>&gt;&gt;&gt;</span><span> </span><span>0o1000</span><span>
</span><span>512</span><span>
</span><span>&gt;&gt;&gt;</span><span> </span><span>01000</span><span>
</span><span>512</span></pre><p>python 3.x</p><pre><span>&gt;&gt;&gt;</span><span> </span><span>01000</span><span>
  </span><span>File</span><span> </span><span>&quot;&lt;stdin&gt;&quot;</span><span>,</span><span> line </span><span>1</span><span>
    </span><span>01000</span><span>
        </span><span>^</span><span>
</span><span>SyntaxError</span><span>:</span><span> invalid token
</span><span>&gt;&gt;&gt;</span><span> </span><span>0o1000</span><span>
</span><span>512</span></pre><hr/><h2>不等运算符</h2><p>Python 2.x中不等于有两种写法 != 和 &lt;&gt;</p><p>Python 3.x中去掉了&lt;&gt;, 只有!=一种写法，还好，我从来没有使用&lt;&gt;的习惯</p><hr/><h2>去掉了repr表达式``</h2><p>Python 2.x 中反引号``相当于repr函数的作用</p><p>Python 3.x 中去掉了``这种写法，只允许使用repr函数，这样做的目的是为了使代码看上去更清晰么？不过我感觉用repr的机会很少，一般只在debug的时候才用，多数时候还是用str函数来用字符串描述对象。</p><pre><span>def</span><span> sendMail</span><span>(</span><span>from_</span><span>:</span><span> str</span><span>,</span><span> to</span><span>:</span><span> str</span><span>,</span><span> title</span><span>:</span><span> str</span><span>,</span><span> body</span><span>:</span><span> str</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>bool</span><span>:</span><span>
    </span><span>pass</span></pre><hr/><h2>多个模块被改名（根据PEP8）</h2><table><tr><th colspan="1" rowspan="1">旧的名字</th><th colspan="1" rowspan="1">新的名字</th></tr><tr><td colspan="1" rowspan="1">_winreg</td><td colspan="1" rowspan="1">winreg</td></tr><tr><td colspan="1" rowspan="1">ConfigParser</td><td colspan="1" rowspan="1">configparser</td></tr><tr><td colspan="1" rowspan="1">copy_reg</td><td colspan="1" rowspan="1">copyreg</td></tr><tr><td colspan="1" rowspan="1">Queue</td><td colspan="1" rowspan="1">queue</td></tr><tr><td colspan="1" rowspan="1">SocketServer</td><td colspan="1" rowspan="1">socketserver</td></tr><tr><td colspan="1" rowspan="1">repr</td><td colspan="1" rowspan="1">reprlib</td></tr></table><p>StringIO模块现在被合并到新的io模组内。 new, md5, gopherlib等模块被删除。 Python 2.6已经支援新的io模组。</p><p>httplib, BaseHTTPServer, CGIHTTPServer, SimpleHTTPServer, Cookie, cookielib被合并到http包内。</p><p>取消了exec语句，只剩下exec()函数。 Python 2.6已经支援exec()函数。</p><hr/><h2>5.数据类型</h2><p>1）Py3.X去除了long类型，现在只有一种整型——int，但它的行为就像2.X版本的long</p><p>2）新增了bytes类型，对应于2.X版本的八位串，定义一个bytes字面量的方法如下：</p><pre><span>&gt;&gt;&gt;</span><span> b </span><span>=</span><span> b</span><span>'china'</span><span> 
</span><span>&gt;&gt;&gt;</span><span> type</span><span>(</span><span>b</span><span>)</span><span> 
</span><span>&lt;</span><span>type </span><span>'bytes'</span><span>&gt;</span><span> </span></pre><p>str对象和bytes对象可以使用.encode() (str -&gt; bytes) or .decode() (bytes -&gt; str)方法相互转化。</p><pre><span>&gt;&gt;&gt;</span><span> s </span><span>=</span><span> b</span><span>.</span><span>decode</span><span>()</span><span> 
</span><span>&gt;&gt;&gt;</span><span> s 
</span><span>'china'</span><span> 
</span><span>&gt;&gt;&gt;</span><span> b1 </span><span>=</span><span> s</span><span>.</span><span>encode</span><span>()</span><span> 
</span><span>&gt;&gt;&gt;</span><span> b1 
b</span><span>'china'</span><span> </span></pre><p>3）dict的.keys()、.items 和.values()方法返回迭代器，而之前的iterkeys()等函数都被废弃。同时去掉的还有 dict.has_key()，用 in替代它吧 。</p><br clear="none"/></div></span>
</div></body></html> 